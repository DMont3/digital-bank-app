This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-12T03:15:17.313Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.gitignore
package.json
src/config/env.ts
src/models/user.model.ts
src/plugins/auth.ts
src/plugins/cors.ts
src/plugins/swagger.ts
src/routes/auth.routes.ts
src/routes/user.routes.ts
src/server.ts
src/services/auth.service.ts
src/services/user.service.ts
tsconfig.json

================================================================
Repository Files
================================================================

================
File: .gitignore
================
# Dependencies
node_modules
npm-debug.log
yarn-debug.log
yarn-error.log

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Build output
dist
build
lib

# Coverage directory
coverage

# Logs
logs
*.log

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# TypeScript
*.tsbuildinfo

# Temp directories
.temp
.tmp
.cache

================
File: package.json
================
{
  "name": "yfi-bank-backend",
  "version": "1.0.0",
  "description": "YFI Bank Backend",
  "main": "dist/server.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@fastify/cors": "^8.4.1",
    "@fastify/swagger": "^8.12.0",
    "@fastify/swagger-ui": "^1.10.1",
    "@supabase/supabase-js": "^2.39.0",
    "@types/crypto-js": "^4.2.2",
    "@types/nodemailer": "^6.4.17",
    "crypto-js": "^4.2.0",
    "dotenv": "^16.3.1",
    "fastify": "^4.24.3",
    "fastify-plugin": "^4.5.1",
    "nodemailer": "^6.9.16"
  },
  "devDependencies": {
    "@types/node": "^20.10.4",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.3.3"
  }
}

================
File: src/config/env.ts
================
import dotenv from 'dotenv'

dotenv.config()

interface Config {
  port: number
  supabaseUrl: string
  supabaseKey: string
  supabaseServiceRoleKey: string
  frontendUrl: string
}

export const config: Config = {
  port: Number(process.env.PORT) || 3000,
  supabaseUrl: process.env.SUPABASE_URL || '',
  supabaseKey: process.env.SUPABASE_KEY || '',
  supabaseServiceRoleKey: process.env.SUPABASE_SERVICE_ROLE_KEY || '',
  frontendUrl: process.env.FRONTEND_URL || ''
}

// Validação das variáveis obrigatórias
const requiredEnvs: (keyof Config)[] = ['supabaseUrl', 'supabaseKey', 'supabaseServiceRoleKey', 'frontendUrl']
for (const env of requiredEnvs) {
  if (!config[env]) {
    throw new Error(`Missing required environment variable: ${env}`)
  }
}

================
File: src/models/user.model.ts
================
import { Session, User as SupabaseUser } from '@supabase/supabase-js'

export interface Address {
  cep: string
  street: string
  number: string
  complement?: string
  neighborhood: string
  city: string
  state: string
}

export interface UserProfile {
  id: string
  email: string
  name?: string
  cpf?: string
  phone?: string
  birth_date?: string
  address?: Address
  email_verified?: boolean
  phone_verified?: boolean
  created_at?: string
  updated_at?: string
}

export interface CreateUserDTO {
  email: string
  password: string
  name: string
  cpf: string
  phone: string
  birthDate: string
  address: Address
}

export interface LoginDTO {
  email: string
  password: string
}

export interface AuthResponse {
  user: UserProfile | null
  session: Session | null
}

================
File: src/plugins/auth.ts
================
import { FastifyInstance, FastifyReply, FastifyRequest } from 'fastify'
import fp from 'fastify-plugin'
import { createClient, User as SupabaseUser } from '@supabase/supabase-js'
import { config } from '../config/env'

// Declaração única do tipo user no request
declare module 'fastify' {
  interface FastifyRequest {
    user?: SupabaseUser
  }
}

export default fp(async function (fastify: FastifyInstance) {
  const supabase = createClient(config.supabaseUrl, config.supabaseKey)

  fastify.decorate('authenticate', async function(request: FastifyRequest, reply: FastifyReply) {
    try {
      const authHeader = request.headers.authorization
      if (!authHeader) {
        throw new Error('No authorization header')
      }

      const token = authHeader.replace('Bearer ', '')
      if (!token) {
        throw new Error('Invalid token format')
      }

      const { data: { user }, error } = await supabase.auth.getUser(token)
      if (error || !user) {
        throw new Error('Invalid token')
      }

      request.user = user
    } catch (error: any) {
      reply.code(401).send({ error: 'Unauthorized', message: error.message })
    }
  })
}, { name: 'auth' })

================
File: src/plugins/cors.ts
================
import { FastifyInstance } from 'fastify'
import cors from '@fastify/cors'

export async function corsPlugin(fastify: FastifyInstance) {
  await fastify.register(cors, {
    origin: true, // Em produção, você deve especificar os domínios permitidos
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
    credentials: true,
  })
}

================
File: src/plugins/swagger.ts
================
import { FastifyInstance } from 'fastify'
import fastifySwagger from '@fastify/swagger'
import fastifySwaggerUi from '@fastify/swagger-ui'

export async function swaggerPlugin(fastify: FastifyInstance) {
  await fastify.register(fastifySwagger, {
    openapi: {
      info: {
        title: 'YFI Bank API',
        description: 'YFI Bank API documentation',
        version: '1.0.0'
      },
      servers: [
        {
          url: 'http://localhost:3000',
          description: 'Development server'
        }
      ],
      components: {
        securitySchemes: {
          bearerAuth: {
            type: 'http',
            scheme: 'bearer',
            bearerFormat: 'JWT'
          }
        }
      }
    }
  })

  await fastify.register(fastifySwaggerUi, {
    routePrefix: '/documentation',
    uiConfig: {
      docExpansion: 'list',
      deepLinking: false
    },
    staticCSP: true
  })
}

================
File: src/routes/auth.routes.ts
================
import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify'
import { AuthService } from '../services/auth.service'
import { CreateUserDTO, LoginDTO } from '../models/user.model'
import { createClient } from '@supabase/supabase-js'
import { config } from '../config/env'

export async function authRoutes(fastify: FastifyInstance) {
  const authService = new AuthService()
  
  // Cliente normal para operações públicas
  const supabase = createClient(config.supabaseUrl, config.supabaseKey)
  
  // Cliente com service_role para operações admin
  const adminSupabase = createClient(config.supabaseUrl, config.supabaseServiceRoleKey, {
    auth: {
      autoRefreshToken: false,
      persistSession: false
    }
  })

  // Helper para extrair e validar token
  const validateToken = async (request: FastifyRequest): Promise<string> => {
    const authHeader = request.headers.authorization
    if (!authHeader) {
      throw new Error('No authorization header')
    }

    const token = authHeader.replace('Bearer ', '')
    if (!token) {
      throw new Error('Invalid token format')
    }

    // Verifica se o token é válido no Supabase
    const { data: { user }, error } = await supabase.auth.getUser(token)
    if (error || !user) {
      throw new Error('Invalid token')
    }

    return token
  }

  // Enviar código de verificação por email
  fastify.post<{ Body: { email: string } }>('/verify-email', async (request, reply) => {
    try {
      const { email } = request.body
      if (!email) throw new Error('Email is required')

      console.log('Checking for existing user with email:', email)

      // Procura usuário existente com este email
      const { data: { users }, error: searchError } = await adminSupabase.auth.admin.listUsers()
      if (searchError) {
        console.error('Error listing users:', searchError)
        throw searchError
      }

      console.log('Total users found:', users.length)

      // Encontra usuário com o email específico
      const existingUser = users.find(user => user.email?.toLowerCase() === email.toLowerCase())
      
      if (existingUser) {
        console.log('Found user:', {
          id: existingUser.id,
          email: existingUser.email,
          confirmed: existingUser.email_confirmed_at,
          created: existingUser.created_at
        })

        // Se o usuário existe e já está confirmado, retorna um erro
        if (existingUser.email_confirmed_at) {
          console.log('User already confirmed, returning error')
          return reply.code(400).send({ 
            error: 'Email já cadastrado',
            message: 'Este email já está cadastrado. Por favor, faça login.'
          })
        }

        // Se o usuário existe e não está confirmado (ou está em processo de signup)
        if (!existingUser.email_confirmed_at || existingUser.user_metadata?.flow === 'signup') {
          console.log('Attempting to delete pending user:', existingUser.id)
          const { error: deleteError } = await adminSupabase.auth.admin.deleteUser(existingUser.id)
          
          if (deleteError) {
            console.error('Error deleting user:', deleteError)
            throw deleteError
          }
          
          console.log('Successfully deleted pending user:', existingUser.id)
        } else {
          console.log('User already confirmed, not deleting')
        }
      } else {
        console.log('No existing user found with email:', email)
      }

      console.log('Sending new verification code...')

      // Envia o código usando signInWithOtp
      const { error } = await adminSupabase.auth.signInWithOtp({
        email,
        options: {
          shouldCreateUser: true,
          data: {
            flow: 'signup'
          }
        }
      })
      
      if (error) {
        console.error('Error sending OTP:', error)
        throw error
      }

      console.log('Verification code sent successfully')

      return reply.code(200).send({ message: 'Verification code sent. Check your email.' })
    } catch (error: any) {
      console.error('Failed to send verification code:', error)
      return reply.code(400).send({ 
        error: 'Failed to send verification code',
        message: error.message 
      })
    }
  })

  // Verificar código e registrar usuário
  fastify.post<{ Body: CreateUserDTO & { token: string } }>('/verify-code', async (request, reply) => {
    try {
      const { email, token, ...userData } = request.body
      console.log('Received registration data:', request.body)

      // Validação dos campos obrigatórios
      const requiredFields = ['email', 'token', 'name', 'cpf', 'phone', 'birthDate'] as const
      const missingFields = requiredFields.filter(field => !request.body[field])
      
      if (missingFields.length > 0) {
        throw new Error(`Campos obrigatórios faltando: ${missingFields.join(', ')}. Por favor, preencha todos os campos e tente novamente.`)
      }

      if (!email || !token) {
        throw new Error('Email e código de verificação são obrigatórios')
      }

      // Verifica o código OTP
      console.log('Verifying OTP...')
      const { data: verifyData, error: verifyError } = await supabase.auth.verifyOtp({
        email,
        token,
        type: 'signup'
      })
      
      if (verifyError) {
        console.error('OTP verification failed:', verifyError)
        // Mensagens personalizadas baseadas no tipo de erro
        if (verifyError.message.includes('expired')) {
          throw new Error('O código de verificação expirou. Por favor, solicite um novo código na tela anterior.')
        } else if (verifyError.message.includes('invalid')) {
          throw new Error('Código de verificação inválido. Verifique se digitou corretamente ou solicite um novo código.')
        }
        throw new Error('Erro ao verificar o código. Por favor, tente novamente ou solicite um novo código.')
      }
      
      if (!verifyData.user?.id) {
        console.error('No user returned after verifyOtp')
        throw new Error('Erro no processo de verificação. Por favor, tente novamente do início.')
      }

      console.log('OTP verified successfully, updating user data...')
      
      // Agora atualizamos a senha e metadados do usuário usando o cliente admin
      const { error: updateError } = await adminSupabase.auth.admin.updateUserById(
        verifyData.user.id,
        {
          password: userData.password,
          user_metadata: {
            name: userData.name,
            phone: userData.phone
          }
        }
      )
      
      if (updateError) {
        console.error('Failed to update user:', updateError)
        throw new Error('Erro ao atualizar seus dados. Por favor, tente novamente. Se o erro persistir, solicite um novo código de verificação.')
      }

      console.log('User updated successfully, creating profile...')

      // Log dos dados que serão enviados para debug
      console.log('Profile data being sent:', {
        address: userData.address || {},
        birth_date: userData.birthDate || null,
        cpf: userData.cpf || '',
        email,
        name: userData.name || '',
        phone: userData.phone || '',
        user_id: verifyData.user.id
      })

      // Criar o perfil do usuário usando a função do banco com os parâmetros na ordem correta
      const { data: profile, error: profileError } = await adminSupabase.rpc('register_user_profile', {
        p_address: userData.address || {},
        p_birth_date: userData.birthDate || null,
        p_cpf: userData.cpf || '',
        p_email: email,
        p_name: userData.name || '',
        p_phone: userData.phone || '',
        p_user_id: verifyData.user.id
      })

      if (profileError) {
        console.error('Failed to create user profile:', profileError)
        // Se falhar ao criar o perfil, deleta o usuário do Auth
        const { error: deleteError } = await adminSupabase.auth.admin.deleteUser(verifyData.user.id)
        if (deleteError) {
          console.error('Failed to cleanup user after profile creation failed:', deleteError)
        }
        throw new Error('Erro ao criar seu perfil. Por favor, tente o processo de registro novamente. Se o erro persistir, verifique se todos os dados estão preenchidos corretamente.')
      }

      console.log('Profile created successfully:', profile)

      return reply.code(201).send({
        user: profile,
        session: verifyData.session,
        token: verifyData.session?.access_token,
        message: 'Registration successful.'
      })
    } catch (error: any) {
      console.error('Registration failed:', error)
      return reply.code(400).send({ 
        error: 'Registration failed',
        message: error.message,
        details: error.details || error.hint || undefined
      })
    }
  })

  // Login
  fastify.post<{ Body: LoginDTO }>('/login', async (request, reply) => {
    try {
      const response = await authService.login(request.body)
      return reply.code(200).send(response)
    } catch (error: any) {
      return reply.code(401).send({ 
        error: 'Authentication failed',
        message: error.message 
      })
    }
  })

  // Logout
  fastify.post('/logout', async (request, reply) => {
    try {
      const token = await validateToken(request)
      await authService.logout(token)
      return reply.code(200).send({ message: 'Logged out successfully' })
    } catch (error: any) {
      return reply.code(401).send({ 
        error: 'Logout failed',
        message: error.message 
      })
    }
  })

  // Obter usuário atual
  fastify.get('/me', async (request, reply) => {
    try {
      const token = await validateToken(request)
      const user = await authService.getCurrentUser(token)
      return reply.code(200).send(user)
    } catch (error: any) {
      return reply.code(401).send({ 
        error: 'Failed to get user profile',
        message: error.message 
      })
    }
  })

  // Reset password
  fastify.post<{ Body: { email: string } }>('/reset-password', async (request, reply) => {
    try {
      const { email } = request.body
      if (!email) {
        return reply.code(400).send({ error: 'Email is required' })
      }

      await authService.resetPassword(email)
      return reply.code(200).send({ message: 'Password reset email sent' })
    } catch (error: any) {
      return reply.code(400).send({ 
        error: 'Failed to send reset password email',
        message: error.message 
      })
    }
  })
}

================
File: src/routes/user.routes.ts
================
import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify'
import { UserService } from '../services/user.service'
import { UserProfile } from '../models/user.model'
import { createClient } from '@supabase/supabase-js'
import { config } from '../config/env'

const userService = new UserService()

export async function userRoutes(fastify: FastifyInstance) {
  const supabase = createClient(config.supabaseUrl, config.supabaseKey)

  // Middleware de autenticação
  const authenticate = async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const authHeader = request.headers.authorization
      if (!authHeader) {
        throw new Error('No authorization header')
      }

      const token = authHeader.replace('Bearer ', '')
      if (!token) {
        throw new Error('Invalid token format')
      }

      // Verifica se o token é válido no Supabase
      const { data: { user }, error } = await supabase.auth.getUser(token)
      if (error || !user) {
        throw new Error('Invalid token')
      }

      // Adiciona o usuário ao request para uso nas rotas
      request.user = user
    } catch (error: any) {
      reply.code(401).send({ error: 'Unauthorized', message: error.message })
    }
  }

  // Todas as rotas aqui requerem autenticação
  fastify.addHook('preHandler', authenticate)

  // Obter perfil do usuário
  fastify.get('/profile', async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      if (!request.user) {
        return reply.code(401).send({ error: 'User not authenticated' })
      }
      const profile = await userService.getProfile(request.user.id)
      reply.send(profile)
    } catch (error: any) {
      reply.code(400).send({ error: error.message })
    }
  })

  // Atualizar perfil
  fastify.put<{ Body: Partial<UserProfile> }>('/profile', async (request: FastifyRequest<{ Body: Partial<UserProfile> }>, reply: FastifyReply) => {
    try {
      if (!request.user) {
        return reply.code(401).send({ error: 'User not authenticated' })
      }
      const updatedProfile = await userService.updateProfile(request.user.id, request.body)
      reply.send(updatedProfile)
    } catch (error: any) {
      reply.code(400).send({ error: error.message })
    }
  })

  // Excluir conta
  fastify.delete('/account', async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      if (!request.user) {
        return reply.code(401).send({ error: 'User not authenticated' })
      }
      await userService.deleteAccount(request.user.id)
      reply.send({ message: 'Account deleted successfully' })
    } catch (error: any) {
      reply.code(400).send({ error: error.message })
    }
  })
}

================
File: src/server.ts
================
import 'dotenv/config'
import Fastify from 'fastify'
import cors from '@fastify/cors'
import { authRoutes } from './routes/auth.routes'
import { userRoutes } from './routes/user.routes'
import { swaggerPlugin } from './plugins/swagger'

async function bootstrap() {
  const fastify = Fastify({
    logger: true
  })

  // Registrar plugins
  await fastify.register(cors, {
    origin: process.env.FRONTEND_URL || 'http://localhost:5173',
    credentials: true
  })
  
  await fastify.register(swaggerPlugin)

  // Registrar rotas
  await fastify.register(authRoutes, { prefix: '/auth' })
  await fastify.register(userRoutes, { prefix: '/users' })

  // Iniciar servidor
  try {
    await fastify.listen({ 
      port: Number(process.env.PORT) || 3000,
      host: '0.0.0.0'
    })
  } catch (err) {
    fastify.log.error(err)
    process.exit(1)
  }
}

bootstrap()

================
File: src/services/auth.service.ts
================
import { createClient } from '@supabase/supabase-js'
import { config } from '../config/env'
import { CreateUserDTO, LoginDTO, AuthResponse, UserProfile } from '../models/user.model'

export class AuthService {
  private supabase

  constructor() {
    this.supabase = createClient(config.supabaseUrl, config.supabaseKey)
  }

  public async createUserProfile(userId: string, userData: CreateUserDTO): Promise<UserProfile> {
    const { data, error } = await this.supabase
      .from('users')
      .insert({
        id: userId,
        email: userData.email,
        name: userData.name,
        cpf: userData.cpf,
        phone: userData.phone,
        birth_date: userData.birthDate,
        address: userData.address,
        email_verified: true,
        phone_verified: false,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select()
      .single()

    if (error) {
      // Em caso de erro, deletamos o usuário do Auth
      await this.supabase.auth.admin.deleteUser(userId)
      throw error
    }

    return data
  }

  async login(credentials: LoginDTO): Promise<AuthResponse> {
    const { data: authData, error: authError } = await this.supabase.auth.signInWithPassword({
      email: credentials.email,
      password: credentials.password
    })

    if (authError) throw authError
    if (!authData.user) {
      throw new Error('Authentication failed')
    }

    const userProfile = await this.getUserProfile(authData.user.id)
    return {
      user: userProfile,
      session: authData.session
    }
  }

  async logout(token: string) {
    const { error } = await this.supabase.auth.signOut()
    if (error) throw error
  }

  async getCurrentUser(token: string): Promise<UserProfile> {
    const { data: { user }, error } = await this.supabase.auth.getUser(token)
    if (error || !user) {
      throw error || new Error('Invalid token')
    }
    return await this.getUserProfile(user.id)
  }

  async resetPassword(email: string) {
    const { error } = await this.supabase.auth.resetPasswordForEmail(email)
    if (error) throw error
  }

  async verifyEmail(token: string) {
    const { error } = await this.supabase.auth.verifyOtp({
      token_hash: token,
      type: 'email'
    })

    if (error) throw error

    // Atualizar status de verificação de email no perfil
    const { data: { user } } = await this.supabase.auth.getUser()
    if (user) {
      await this.supabase
        .from('users')
        .update({ email_verified: true })
        .eq('id', user.id)
    }
  }

  private async getUserProfile(userId: string): Promise<UserProfile> {
    const { data, error } = await this.supabase
      .from('users')
      .select('*')
      .eq('id', userId)
      .single()
    if (error) throw error
    return data
  }
}

================
File: src/services/user.service.ts
================
import { createClient } from '@supabase/supabase-js'
import { UserProfile } from '../models/user.model'

export class UserService {
  private supabase

  constructor() {
    this.supabase = createClient(
      process.env.SUPABASE_URL!,
      process.env.SUPABASE_KEY!
    )
  }

  async getProfile(userId: string): Promise<UserProfile> {
    const { data, error } = await this.supabase
      .from('users')
      .select('*')
      .eq('id', userId)
      .single()

    if (error) throw error
    return data as UserProfile
  }

  async updateProfile(userId: string, userData: Partial<UserProfile>): Promise<UserProfile> {
    const { data, error } = await this.supabase
      .from('users')
      .update(userData)
      .eq('id', userId)
      .select()
      .single()

    if (error) throw error
    return data as UserProfile
  }

  async deleteAccount(userId: string): Promise<void> {
    // Deletar perfil do usuário
    const { error: profileError } = await this.supabase
      .from('users')
      .delete()
      .eq('id', userId)

    if (profileError) throw profileError

    // Deletar usuário do auth
    const { error: authError } = await this.supabase.auth.admin.deleteUser(userId)
    if (authError) throw authError
  }
}

================
File: tsconfig.json
================
{
    "compilerOptions": {
      "target": "ES2020",
      "module": "commonjs",
      "lib": ["ES2020"],
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true,
      "outDir": "./dist",
      "rootDir": "./src",
      "baseUrl": ".",
      "paths": {
        "@/*": ["src/*"]
      }
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules"]
  }
