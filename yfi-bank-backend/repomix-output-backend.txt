This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-08T19:05:17.450Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.gitignore
package.json
src/config/env.ts
src/models/user.model.ts
src/plugins/cors.ts
src/plugins/jwt.ts
src/plugins/swagger.ts
src/routes/auth.routes.ts
src/routes/user.routes.ts
src/server.ts
src/services/auth.service.ts
src/services/user.service.ts
tsconfig.json

================================================================
Repository Files
================================================================

================
File: .gitignore
================
node_modules
dist
.env

================
File: package.json
================
{
  "name": "yfi-bank-backend",
  "version": "1.0.0",
  "description": "YFI Bank Backend",
  "main": "dist/server.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@fastify/cors": "^8.4.1",
    "@fastify/jwt": "^7.2.3",
    "@fastify/swagger": "^8.12.0",
    "@fastify/swagger-ui": "^1.10.1",
    "@supabase/supabase-js": "^2.39.0",
    "@types/nodemailer": "^6.4.17",
    "dotenv": "^16.3.1",
    "fastify": "^4.24.3",
    "fastify-plugin": "^4.5.1",
    "nodemailer": "^6.9.16"
  },
  "devDependencies": {
    "@types/node": "^20.10.4",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.3.3"
  }
}

================
File: src/config/env.ts
================
import dotenv from 'dotenv'

dotenv.config()

interface Config {
  port: number
  supabaseUrl: string
  supabaseKey: string
  jwtSecret: string
}

export const config: Config = {
  port: Number(process.env.PORT) || 3000,
  supabaseUrl: process.env.SUPABASE_URL || '',
  supabaseKey: process.env.SUPABASE_KEY || '',
  jwtSecret: process.env.JWT_SECRET || ''
}

// Validação das variáveis obrigatórias
const requiredEnvs: (keyof Config)[] = ['supabaseUrl', 'supabaseKey', 'jwtSecret']
for (const env of requiredEnvs) {
  if (!config[env]) {
    throw new Error(`Missing required environment variable: ${env}`)
  }
}

================
File: src/models/user.model.ts
================
import { Session } from '@supabase/supabase-js';

export interface Address {
  cep: string
  street: string
  number: string
  complement?: string
  neighborhood: string
  city: string
  state: string
}

export interface User {
  id: string
  email: string
  name: string
  cpf: string
  phone: string
  birthDate: string
  address: Address
  emailVerified?: boolean
  phoneVerified?: boolean
  createdAt?: string
  updatedAt?: string
}

export interface CreateUserDTO {
  email: string
  password: string
  name: string
  cpf: string
  phone: string
  birthDate: string
  address: Address
}

export interface LoginDTO {
  email: string
  password: string
}

export interface AuthResponse {
  user: User
  session: Session | null
  token?: string
}

================
File: src/plugins/cors.ts
================
import { FastifyInstance } from 'fastify'
import cors from '@fastify/cors'

export async function corsPlugin(fastify: FastifyInstance) {
  await fastify.register(cors, {
    origin: true, // Em produção, você deve especificar os domínios permitidos
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
    credentials: true,
  })
}

================
File: src/plugins/jwt.ts
================
import { FastifyInstance, FastifyReply, FastifyRequest } from 'fastify'
import fastifyJwt from '@fastify/jwt'
import fp from 'fastify-plugin'

declare module 'fastify' {
  interface FastifyInstance {
    authenticate: (request: FastifyRequest, reply: FastifyReply) => Promise<void>
  }
}

declare module '@fastify/jwt' {
  interface FastifyJWT {
    user: {
      id: string
      email: string
    }
  }
}

export default fp(async function (fastify: FastifyInstance) {
  fastify.register(fastifyJwt, {
    secret: process.env.JWT_SECRET || 'your-secret-key'
  })

  fastify.decorate('authenticate', async function(request: FastifyRequest, reply: FastifyReply) {
    try {
      await request.jwtVerify()
    } catch (err) {
      reply.code(401).send({ error: 'Unauthorized' })
    }
  })
}, { name: 'jwt' })

================
File: src/plugins/swagger.ts
================
import { FastifyInstance } from 'fastify'
import fastifySwagger from '@fastify/swagger'
import fastifySwaggerUi from '@fastify/swagger-ui'

export async function swaggerPlugin(fastify: FastifyInstance) {
  await fastify.register(fastifySwagger, {
    openapi: {
      info: {
        title: 'YFI Bank API',
        description: 'YFI Bank API documentation',
        version: '1.0.0'
      },
      servers: [
        {
          url: 'http://localhost:3000',
          description: 'Development server'
        }
      ],
      components: {
        securitySchemes: {
          bearerAuth: {
            type: 'http',
            scheme: 'bearer',
            bearerFormat: 'JWT'
          }
        }
      }
    }
  })

  await fastify.register(fastifySwaggerUi, {
    routePrefix: '/documentation',
    uiConfig: {
      docExpansion: 'list',
      deepLinking: false
    },
    staticCSP: true
  })
}

================
File: src/routes/auth.routes.ts
================
import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify'
import { AuthService } from '../services/auth.service'
import { CreateUserDTO, LoginDTO } from '../models/user.model'

const authService = new AuthService()

export async function authRoutes(fastify: FastifyInstance) {
  // Enviar código de verificação por email
  fastify.post<{ Body: { email: string } }>(
    '/verify-email',
    {
      schema: {
        body: {
          type: 'object',
          required: ['email'],
          properties: {
            email: { type: 'string', format: 'email' }
          }
        }
      }
    },
    async (request: FastifyRequest<{ Body: { email: string } }>, reply: FastifyReply) => {
      try {
        const result = await authService.sendEmailVerification(request.body.email)
        reply.send(result)
      } catch (error: any) {
        reply.code(400).send({ error: error.message })
      }
    }
  )

  // Verificar código de email
  fastify.post<{ Body: { email: string; code: string } }>(
    '/verify-email-code',
    {
      schema: {
        body: {
          type: 'object',
          required: ['email', 'code'],
          properties: {
            email: { type: 'string', format: 'email' },
            code: { type: 'string' }
          }
        }
      }
    },
    async (request: FastifyRequest<{ Body: { email: string; code: string } }>, reply: FastifyReply) => {
      try {
        const result = await authService.verifyEmailCode(
          request.body.email,
          request.body.code
        )
        reply.send(result)
      } catch (error: any) {
        reply.code(400).send({ error: error.message })
      }
    }
  )

  // Registro completo
  fastify.post<{ Body: CreateUserDTO }>(
    '/register',
    {
      schema: {
        body: {
          type: 'object',
          required: ['email', 'password', 'name', 'cpf', 'phone', 'birthDate', 'address'],
          properties: {
            email: { type: 'string', format: 'email' },
            password: { type: 'string', minLength: 6 },
            name: { type: 'string' },
            cpf: { type: 'string' },
            phone: { type: 'string' },
            birthDate: { type: 'string' },
            address: {
              type: 'object',
              required: ['cep', 'street', 'number', 'neighborhood', 'city', 'state'],
              properties: {
                cep: { type: 'string' },
                street: { type: 'string' },
                number: { type: 'string' },
                complement: { type: 'string' },
                neighborhood: { type: 'string' },
                city: { type: 'string' },
                state: { type: 'string' }
              }
            }
          }
        }
      }
    },
    async (request: FastifyRequest<{ Body: CreateUserDTO }>, reply: FastifyReply) => {
      try {
        const user = await authService.register(request.body)
        reply.code(201).send(user)
      } catch (error: any) {
        if (error.errors) {
          reply.code(400).send({ errors: error.errors })
        } else {
          reply.code(400).send({ error: error.message })
        }
      }
    }
  )

  // Login
  fastify.post<{ Body: LoginDTO }>(
    '/login',
    {
      schema: {
        body: {
          type: 'object',
          required: ['email', 'password'],
          properties: {
            email: { type: 'string', format: 'email' },
            password: { type: 'string' }
          }
        }
      }
    },
    async (request: FastifyRequest<{ Body: LoginDTO }>, reply: FastifyReply) => {
      try {
        const session = await authService.login(request.body)
        reply.send(session)
      } catch (error: any) {
        reply.code(401).send({ error: error.message })
      }
    }
  )

  // Logout
  fastify.post(
    '/logout',
    {
      onRequest: [fastify.authenticate]
    },
    async (request: FastifyRequest, reply: FastifyReply) => {
      try {
        const result = await authService.logout()
        reply.send(result)
      } catch (error: any) {
        reply.code(500).send({ error: error.message })
      }
    }
  )

  // Obter usuário atual
  fastify.get(
    '/me',
    {
      onRequest: [fastify.authenticate]
    },
    async (request: FastifyRequest, reply: FastifyReply) => {
      try {
        const user = await authService.getCurrentUser()
        reply.send(user)
      } catch (error: any) {
        reply.code(401).send({ error: error.message })
      }
    }
  )

  // Atualizar verificação de usuário
  fastify.post<{ Body: { userId: string; type: 'email' | 'phone'; verified: boolean } }>(
    '/update-verification',
    {
      schema: {
        body: {
          type: 'object',
          required: ['userId', 'type', 'verified'],
          properties: {
            userId: { type: 'string' },
            type: { type: 'string', enum: ['email', 'phone'] },
            verified: { type: 'boolean' }
          }
        }
      }
    },
    async (request: FastifyRequest<{ Body: { userId: string; type: 'email' | 'phone'; verified: boolean } }>, reply: FastifyReply) => {
      try {
        const user = await authService.updateUserVerification(
          request.body.userId,
          request.body.type,
          request.body.verified
        );
        reply.send(user);
      } catch (error: any) {
        reply.code(400).send({ error: error.message });
      }
    }
  );
}

================
File: src/routes/user.routes.ts
================
import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify'
import { UserService } from '../services/user.service'
import { User } from '../models/user.model'

const userService = new UserService()

export async function userRoutes(fastify: FastifyInstance) {
  // Todas as rotas aqui requerem autenticação
  fastify.addHook('preHandler', fastify.authenticate)

  // Obter perfil do usuário
  fastify.get('/profile', async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const profile = await userService.getProfile(request.user.id)
      reply.send(profile)
    } catch (error: any) {
      reply.code(400).send({ error: error.message })
    }
  })

  // Atualizar perfil
  fastify.put<{ Body: Partial<User> }>(
    '/profile',
    {
      schema: {
        body: {
          type: 'object',
          properties: {
            name: { type: 'string' },
            phone: { type: 'string' },
            address: {
              type: 'object',
              properties: {
                cep: { type: 'string' },
                street: { type: 'string' },
                number: { type: 'string' },
                complement: { type: 'string' },
                neighborhood: { type: 'string' },
                city: { type: 'string' },
                state: { type: 'string' }
              }
            }
          }
        }
      }
    },
    async (request: FastifyRequest<{ Body: Partial<User> }>, reply: FastifyReply) => {
      try {
        const updatedProfile = await userService.updateProfile(
          request.user.id,
          request.body
        )
        reply.send(updatedProfile)
      } catch (error: any) {
        reply.code(400).send({ error: error.message })
      }
    }
  )

  // Deletar conta
  fastify.delete('/account', async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      await userService.deleteAccount(request.user.id)
      reply.send({ message: 'Account deleted successfully' })
    } catch (error: any) {
      reply.code(400).send({ error: error.message })
    }
  })
}

================
File: src/server.ts
================
import 'dotenv/config'
import Fastify from 'fastify'
import cors from '@fastify/cors'
import { authRoutes } from './routes/auth.routes'
import { userRoutes } from './routes/user.routes'
import { swaggerPlugin } from './plugins/swagger'
import jwtPlugin from './plugins/jwt'

async function bootstrap() {
  const fastify = Fastify({
    logger: true
  })

  // Registrar plugins
  await fastify.register(cors, {
    origin: process.env.FRONTEND_URL || 'http://localhost:5173',
    credentials: true
  })
  
  await fastify.register(jwtPlugin)
  await fastify.register(swaggerPlugin)

  // Registrar rotas
  await fastify.register(authRoutes, { prefix: '/auth' })
  await fastify.register(userRoutes, { prefix: '/users' })

  // Iniciar servidor
  try {
    await fastify.listen({ 
      port: Number(process.env.PORT) || 3000,
      host: '0.0.0.0'
    })
  } catch (err) {
    fastify.log.error(err)
    process.exit(1)
  }
}

bootstrap()

================
File: src/services/auth.service.ts
================
import { createClient } from '@supabase/supabase-js'
import { AuthResponse, CreateUserDTO, LoginDTO, User } from '../models/user.model'

export class AuthService {
  private supabase

  constructor() {
    this.supabase = createClient(
      process.env.SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY! // Usa a service_role key
    )
  }

  async sendEmailVerification(email: string) {
    // Primeiro remove usuários não confirmados com o mesmo email
    const { data: users, error: usersError } = await this.supabase.auth.admin
      .listUsers()

    if (!usersError) {
      const unconfirmedUsers = users.users.filter(
        user => user.email === email && !user.email_confirmed_at
      )

      for (const user of unconfirmedUsers) {
        await this.supabase.auth.admin.deleteUser(user.id)
      }
    }

    // Envia novo código
    const { error } = await this.supabase.auth.signInWithOtp({
      email,
      options: {
        emailRedirectTo: `${process.env.FRONTEND_URL}/verify-email`
      }
    })

    if (error) throw error

    // Não retorna AuthResponse pois é apenas um passo intermediário
    return { message: 'Verification email sent' }
  }

  async verifyEmailCode(email: string, code: string) {
    const { data, error } = await this.supabase.auth.verifyOtp({
      email,
      token: code,
      type: 'email'
    })

    if (error) throw error

    // Não retorna AuthResponse pois é apenas uma verificação
    return { message: 'Email verified successfully' }
  }

  async register(userData: CreateUserDTO): Promise<AuthResponse> {
    // Primeiro, verifica se o email já foi confirmado
    const { data: existingUser } = await this.supabase.auth.admin
      .listUsers()
      .then(({ data }) => ({
        data: data.users.find(u => u.email === userData.email && u.email_confirmed_at)
      }));

    if (existingUser) {
      throw new Error('Email já está em uso');
    }

    // Registrar usuário no Supabase Auth
    const { data: authData, error: authError } = await this.supabase.auth.signUp({
      email: userData.email,
      password: userData.password,
      options: {
        data: {
          name: userData.name,
          phone: userData.phone
        }
      }
    });

    if (authError) throw authError;

    try {
      // Inserir dados do usuário na tabela users
      const { data: profileData, error: profileError } = await this.supabase
        .from('users')
        .insert({
          id: authData.user?.id,
          email: userData.email,
          name: userData.name,
          cpf: userData.cpf,
          phone: userData.phone,
          birthDate: userData.birthDate,
          address: userData.address,
          emailVerified: false,
          phoneVerified: true, // Por enquanto, sempre true
          createdAt: new Date().toISOString()
        })
        .select()
        .single();

      if (profileError) {
        // Se falhar ao criar o perfil, remove o usuário do auth
        if (authData.user?.id) {
          await this.supabase.auth.admin.deleteUser(authData.user.id);
        }
        throw profileError;
      }

      return {
        user: profileData,
        session: authData.session,
        token: authData.session?.access_token
      };
    } catch (error) {
      // Se ocorrer qualquer erro, remove o usuário do auth
      if (authData.user?.id) {
        await this.supabase.auth.admin.deleteUser(authData.user.id);
      }
      throw error;
    }
  }

  async login(credentials: LoginDTO): Promise<AuthResponse> {
    const { data: authData, error: authError } = await this.supabase.auth.signInWithPassword({
      email: credentials.email,
      password: credentials.password
    })

    if (authError) throw authError

    // Buscar perfil do usuário
    const { data: userData, error: userError } = await this.supabase
      .from('users')
      .select('*')
      .eq('id', authData.user.id)
      .single()

    if (userError) throw userError

    return {
      user: userData as User,
      session: authData.session,
      token: authData.session.access_token
    }
  }

  async logout() {
    const { error } = await this.supabase.auth.signOut()
    if (error) throw error
    return { message: 'Logged out successfully' }
  }

  async getCurrentUser(): Promise<User> {
    const { data: { session }, error: authError } = await this.supabase.auth.getSession()
    if (authError) throw authError
    if (!session) throw new Error('No active session')

    const { data: userData, error: userError } = await this.supabase
      .from('users')
      .select('*')
      .eq('id', session.user.id)
      .single()

    if (userError) throw userError
    return userData as User
  }
}

================
File: src/services/user.service.ts
================
import { createClient } from '@supabase/supabase-js'
import { User } from '../models/user.model'

export class UserService {
  private supabase

  constructor() {
    this.supabase = createClient(
      process.env.SUPABASE_URL!,
      process.env.SUPABASE_KEY!
    )
  }

  async getProfile(userId: string): Promise<User> {
    const { data, error } = await this.supabase
      .from('users')
      .select('*')
      .eq('id', userId)
      .single()

    if (error) throw error
    return data as User
  }

  async updateProfile(userId: string, userData: Partial<User>): Promise<User> {
    const { data, error } = await this.supabase
      .from('users')
      .update(userData)
      .eq('id', userId)
      .select()
      .single()

    if (error) throw error
    return data as User
  }

  async deleteAccount(userId: string): Promise<void> {
    // Deletar perfil do usuário
    const { error: profileError } = await this.supabase
      .from('users')
      .delete()
      .eq('id', userId)

    if (profileError) throw profileError

    // Deletar usuário do auth
    const { error: authError } = await this.supabase.auth.admin.deleteUser(userId)
    if (authError) throw authError
  }
}

================
File: tsconfig.json
================
{
    "compilerOptions": {
      "target": "ES2020",
      "module": "commonjs",
      "lib": ["ES2020"],
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true,
      "outDir": "./dist",
      "rootDir": "./src",
      "baseUrl": ".",
      "paths": {
        "@/*": ["src/*"]
      }
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules"]
  }
